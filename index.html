<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Math Algorithm Composer</title>
  <style>
    #renderArea {
        font-family: 'Times New Roman', serif;
    }
    .matdowncontainer {
        padding: 10px;
        margin: 20px;
        max-width: 600px;
    }
    /* Expression wrapper: inline by default */
    .matdowncontainer .matdowninline-expression {
        display: inline-flex;
        align-items: center;
        margin: 2px;
    }
    .matdowncontainer .matdownoperator {
        margin: 0 5px;
        font-weight: bold;
    }
    /* Fraction style for division */
    .matdowncontainer .matdownfraction {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        margin: 2px;
    }
    .matdowncontainer .matdownnumerator {
        border-bottom: 1px solid #000;
        padding: 2px 4px;
        white-space: nowrap;
    }
    .matdowncontainer .matdowndenominator {
        padding: 2px 4px;
        white-space: nowrap;
    }
    /* Grouped parentheses (optional styling) */
    .matdowncontainer .matdowngroup {
        display: inline-block;
        padding: 2px 6px;
        border: 1px dashed #ccc;
        border-radius: 4px;
        margin: 2px;
    }
    /* Exponent style */
    .matdowncontainer .matdownexponent {
        display: inline-block;
        vertical-align: super;
        font-size: 0.8em;
        margin-top: -10px;
    }
    /* General styling for buttons/inputs scoped to our container */
    .matdowncontainer button {
        margin-top: 10px;
        cursor: pointer;
    }
    .matdowncontainer input[type="text"] {
        width: 300px;
        padding: 4px;
    }
    .matdowncontainer textarea {
        width: 100%;
        height: 100px;
        margin-top: 10px;
        font-family: monospace;
    }
    /* context menu styles */
    #matdownContextMenu {
      position: absolute;
      display: none;
      background: #fff;
      border: 1px solid #ccc;
      padding: 8px;
      z-index: 9999;
      width: 220px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }
    #searchSymbols {
      width: 100%;
      box-sizing: border-box;
      padding: 4px;
      margin-bottom: 8px;
    }
    #symbolList {
      max-height: 200px;
      overflow-y: auto;
    }
    .symbolItem {
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s;
    }
    .symbolItem:hover {
      background: #eee;
    }
  </style>
</head>
<body>

<div class="matdowncontainer">
  <h3>Input </h3>
    -Right-click to insert symbols. (only works when page is parent) <br>
    -Override with your own HTML; i.e. add  <a>&#8826;br&#8827;</a>  to force a new line.
  <input type="text" id="algorithmInput" placeholder="Example: (3^2+1)/(19-10)">
  <button onclick="renderAlgorithm()">Render Algorithm</button>

  <h3>Output:</h3>
  <div id="renderArea"></div>

  <h3>Embeddable HTML Output:</h3>
  <textarea id="htmlOutput" readonly></textarea>
</div>

<!-- Custom context menu (it will also be scoped by our container if moved inside) -->
<div id="matdownContextMenu">
  <input type="text" id="searchSymbols" placeholder="Search symbols...">
  <div id="symbolList"></div>
</div>

<script>
function getUnaryOperatorPrecedence(kind) {
  switch (kind) {
    case '+':
    case '-':
      return 6;

    default:
      return 0;
  }
}

function getBinaryOperatorPrecedence(kind) {
  switch (kind) {
    case '^':
    case '×':
    case '÷':
    case '/':
      return 5;

    case '+':
    case '−':
      return 4;

    case '=':
    case '≠':
    case '<':
    case '≤':
    case '>':
    case '≥':
      return 3;

    default:
      return 0;
  }
}

class MathNode {
  constructor() {
    if (this.constructor == MathNode) {
      throw new Error("Abstract classes can't be instantiated.");
    }
  }

  *getChildren() {
    throw new Error("Abstract method cannot be called.");
  }
}

class MathTreeNode extends MathNode {}

class MathLeafNode extends MathTreeNode {
  *getChildren() {}
}

class MathBranchNode extends MathTreeNode {
  constructor(requiresParenthesis) {
    super();

    if (this.constructor == MathBranchNode) {
      throw new Error("Abstract classes can't be instantiated.");
    }

    this.requiresParenthesis = requiresParenthesis;
  }
}

class MathPartOfNumberNode extends MathLeafNode {}

class MathDigitNode extends MathPartOfNumberNode {
  constructor(digit) {
    super();
    this.digit = digit;
  }
}

class MathDecimalSeperatorNode extends MathPartOfNumberNode {}

class MathNumberNode extends MathBranchNode {
  constructor(digits) {
    super(false);
    this.digits = digits;
  }

  *getChildren() {
    for (let digit of this.digits)
      yield digit;
  }
}

class MathCharacterNode extends MathLeafNode {
  constructor(character) {
    super();
    this.character = character;
  }
}

class MathNameNode extends MathBranchNode {
  constructor(name) {
    super(false);
    this.name = name;
  }

  *getChildren() {
    for (let character of this.name)
      yield character;
  }
}

class MathImplicitMultiplicationNode extends MathBranchNode {
  constructor(left, right) {
    super(false);
    this.left = left;
    this.right = right;
  }

  *getChildren() {
    yield this.left;
    yield this.right;
  }
}

class MathFunctionNode extends MathBranchNode {
  constructor(name, args) {
    super(false);
    this.name = name;
    this.args = args;
  }

  *getChildren() {
    yield this.name;
    for (let arg of this.args)
      yield arg;
  }
}

class MathExponentNode extends MathBranchNode {
  constructor(base, exponent) {
    super(!base instanceof MathNumberNode);
    this.base = base;
    this.exponent = exponent;
  }

  *getChildren() {
    yield this.base;
    yield this.exponent;
  }
}

class MathOperationNode extends MathBranchNode {
 constructor(left, operator, right) {
    super(false);

    if (left instanceof MathOperationNode && getBinaryOperatorPrecedence(left.operator) < getBinaryOperatorPrecedence(operator)) left.requiresParenthesis = true;
    if (right instanceof MathOperationNode && getBinaryOperatorPrecedence(right.operator) < getBinaryOperatorPrecedence(operator)) right.requiresParenthesis = true;
    
    this.left = left;
    this.operator = operator;
    this.right = right;
  }

  *getChildren() {
    yield this.left;
    yield this.right;
  }
}

class MathUnaryOperationNode extends MathBranchNode {
 constructor(operator, expression) {
    super(!base instanceof MathNumberNode);
    this.operator = operator;
    this.expression = expression;
  }

  *getChildren() {
    yield this.expression;
  }
}

class MathFractionNode extends MathBranchNode {
 constructor(numerator, denominator) {
    super(false);
    this.numerator = numerator;
    this.denominator = denominator;
  }

  *getChildren() {
    yield this.numerator;
    yield this.denominator;
  }
}

class MathVisitor {
  visit(node) {
    if (node instanceof MathDigitNode) {
      return this.visitDigit(node);
    } else if (node instanceof MathDecimalSeperatorNode) {
      return this.visitDecimalSeperator(node);
    } else if (node instanceof MathNumberNode) {
      return this.visitNumber(node);
    } else if (node instanceof MathCharacterNode) {
      return this.visitCharacter(node);
    } else if (node instanceof MathNameNode) {
      return this.visitName(node);
    } else if (node instanceof MathImplicitMultiplicationNode) {
      return this.visitImplicitMultiplication(node);
    } else if (node instanceof MathFunctionNode) {
      return this.visitFunction(node);
    } else if (node instanceof MathExponentNode) {
      return this.visitExponent(node);
    } else if (node instanceof MathOperationNode) {
      return this.visitOperation(node);
    } else if (node instanceof MathUnaryOperationNode) {
      return this.visitUnaryOperation(node);
    } else if (node instanceof MathFractionNode) {
      return this.visitFraction(node);
    } else {
      throw new Error(`Unknown node type: ${typeof node}`);
    }
  }

  visitChildren(node) {
    return node.getChildren().map(c => this.visit(c));
  }

  visitDigit(node) {
    throw new Error("Abstract method cannot be called.");
  }

  visitDecimalSeperator(node) {
    throw new Error("Abstract method cannot be called.");
  }

  visitNumber(node) {
    throw new Error("Abstract method cannot be called.");
  }

  visitCharacter(node) {
    throw new Error("Abstract method cannot be called.");
  }

  visitName(node) {
    throw new Error("Abstract method cannot be called.");
  }

  visitImplicitMultiplication(node) {
    throw new Error("Abstract method cannot be called.");
  }

  visitFunction(node) {
    throw new Error("Abstract method cannot be called.");
  }

  visitExponent(node) {
    throw new Error("Abstract method cannot be called.");
  }

  visitOperation(node) {
    throw new Error("Abstract method cannot be called.");
  }

  visitUnaryOperation(node) {
    throw new Error("Abstract method cannot be called.");
  }

  visitFraction(node) {
    throw new Error("Abstract method cannot be called.");
  }
}

class MathHtmlEmmiter extends MathVisitor {
  visit(node) {
    let result = super.visit(node);

    if (node instanceof MathBranchNode && node.requiresParenthesis) {
      result = `<span>(${result})</span>`;
    }

    return result;
  }

  visitDigit(node) {
    return `<span>${node.digit}</span>`;
  }

  visitDecimalSeperator(node) {
    return `<span>${'.'}</span>`;
  }

  visitNumber(node) {
    return `<span>${[...this.visitChildren(node)].join('')}</span>`;
  }

  visitCharacter(node) {
    return `<span>${node.character}</span>`;;
  }

  visitName(node) {
    return `<span>${[...this.visitChildren(node)].join('')}</span>`;
  }

  visitImplicitMultiplication(node) {
    return `<span>${[...this.visitChildren(node)].join('')}</span>`;
  }

  visitFunction(node) {
    return `
      <span class="matdowninline-expression">
        ${this.visit(node.name)}
        <span>(${node.args.map(a => this.visit(a)).join(",")})</span>
      </span>
    `;
  }

  visitExponent(node) {
    return `
      <span class="matdowninline-expression">
        ${this.visit(node.base)}
        <span class="matdownexponent">${this.visit(node.exponent)}</span>
      </span>
    `;
  }

  visitOperation(node) {
    return `
      <span class="matdowninline-expression">
        ${this.visit(node.left)}
        <span class="matdownoperator">${node.operator}</span>
        ${this.visit(node.right)}
      </span>
    `;
  }

  visitUnaryOperation(node) {
    return `
      <span class="matdowninline-expression">
        <span class="matdownoperator">${node.operator}</span>
        ${this.visit(node.expression)}
      </span>
    `;
  }

  visitFraction(node) {
    return `
      <div class="matdownfraction">
        <div class="matdownnumerator">${this.visit(node.numerator)}</div>
        <div class="matdowndenominator">${this.visit(node.denominator)}</div>
      </div>
    `;
  }
}

class MathParser {
  constructor(text) {
    this.text = text.replace(/\s+/g, '');
    this.pos = 0;
    this.currentChar = this.text[this.pos];
  }

  advance() {
    this.pos++;
    this.currentChar = this.pos < this.text.length ? this.text[this.pos] : null;
  }

  peek() {
    return this.pos + 1 < this.text.length ? this.text[this.pos + 1] : null;
  }

  parse() {
    const node = this.expr();
    if (this.currentChar !== null) throw new Error("Unexpected character at end");
    return node;
  }

  eat(char) {
    if (this.currentChar === char) {
      this.advance();
    } else {
      throw new Error(`Expected '${char}', got '${this.currentChar}'`);
    }
  }

  number() {
    const digits = [];
    let hasDecimalSeparator = false;

    while (this.currentChar && /[0-9.]/.test(this.currentChar)) {
      if (this.currentChar === '.') {
        if (hasDecimalSeparator) {
          throw new Error("Multiple decimal separators in number");
        }
        hasDecimalSeparator = true;
        digits.push(new MathDecimalSeperatorNode());
      } else {
        digits.push(new MathDigitNode(parseInt(this.currentChar, 10)));
      }
      this.advance();
    }

    return new MathNumberNode(digits);
  }

  name() {
    const nameParts = [];

    while (this.currentChar && /[a-zA-Z0-9]/.test(this.currentChar)) {
      const char = this.currentChar;
      this.advance();

      if (/[a-zA-Z]/.test(char)) {
        nameParts.push(new MathCharacterNode(char));
      } else {
        nameParts.push(new MathDigitNode(parseInt(char, 10)));
      }
    }

    return new MathNameNode(nameParts);
  }

  primary() {
    if (this.currentChar === '(') {
      this.advance();
      const node = this.expr();
      this.eat(')');
      return node;
    }

    if (/[0-9.]/.test(this.currentChar)) {
      let value = this.number();

      if (/[a-zA-Z]/.test(this.currentChar)) {
        const expression = this.binary(getBinaryOperatorPrecedence('×'));
        value = new MathImplicitMultiplicationNode(value, expression);
      }

      return value;
    }

    if (/[a-zA-Z]/.test(this.currentChar)) {
      const nameNode = this.name();

      if (this.currentChar === '(') {
        this.advance();
        const args = [];

        if (this.currentChar === ')') {
          this.advance();
          return new MathFunctionNode(nameNode, args);
        }

        while (true) {
          const arg = this.expr();
          args.push(arg);

          if (this.currentChar === ',') {
            this.advance();
          } else if (this.currentChar === ')') {
            this.advance();
            break;
          } else {
            throw new Error("Expected ',' or ')' in function arguments");
          }
        }

        return new MathFunctionNode(nameNode, args);
      }

      return nameNode;
    }

    throw new Error("Invalid character in factor");
  }

  binary(parentPrecedence) {
    let left;

    const unaryOperatorPrecedence = getUnaryOperatorPrecedence(this.currentChar);
    if (unaryOperatorPrecedence != 0 && unaryOperatorPrecedence >= parentPrecedence) {
      const operator = this.currentChar;
      this.advance();
      const operand = this.binary(unaryOperatorPrecedence);
      left = new MathUnaryOperationNode(operator, operand);
    } else {
      left = this.primary();
    }

    while (true) {
      const precedence = getBinaryOperatorPrecedence(this.currentChar);
      if (precedence == 0 || precedence <= parentPrecedence)
        break;

      const operator = this.currentChar;
      this.advance();
      const right = this.binary(precedence);

      switch (operator) {
        case '^':
          left = new MathExponentNode(left, right);
          break;
        case '/':
          left = new MathFractionNode(left, right);
          break;
        default:
          left = new MathOperationNode(left, operator, right);
      }
    }

    return left;
  }

  expr() {
    return this.binary(0);
  }
}

/**
 * Public function to parse the input string and produce HTML
 */
function parseAndRender(expr) {
  const parser = new MathParser(expr);
  const emmiter = new MathHtmlEmmiter();

  const tree = parser.parse();
  return emmiter.visit(tree);
}

/**
 * Reads the input, parses & renders, and updates the DOM
 */
function renderAlgorithm() {
  const input = document.getElementById('algorithmInput').value;
  const outputHTML = parseAndRender(input);
  document.getElementById('renderArea').innerHTML = outputHTML;
  document.getElementById('htmlOutput').value =
    '<div class="algorithm">\n' + outputHTML + '\n</div>';
}

// ========================================
// Right-click symbol insertion logic
// ========================================
const mathSymbols = [{ symbol: '±', name: 'plus minus' }, { symbol: '−', name: 'minus sign' }, { symbol: '×', name: 'times sign' }, { symbol: '÷', name: 'division sign' }, { symbol: '∞', name: 'infinity' }, { symbol: '≠', name: 'not equal' }, { symbol: '≈', name: 'approximately equal' }, { symbol: '≡', name: 'equivalent to' }, { symbol: '≅', name: 'congruent to' }, { symbol: '∴', name: 'therefore' }, { symbol: '∵', name: 'because' }, { symbol: '∑', name: 'summation' }, { symbol: '∏', name: 'product' }, { symbol: '∫', name: 'integral' }, { symbol: '∂', name: 'partial derivative' }, { symbol: '√', name: 'square root' }, { symbol: '³', name: 'cube exponent' }, { symbol: '²', name: 'square exponent' }, { symbol: '°', name: 'degree' }, { symbol: '∀', name: 'for all' }, { symbol: '∃', name: 'there exists' }, { symbol: '∈', name: 'element of' }, { symbol: '⇒', name: 'implies' }, { symbol: '⇔', name: 'if and only if' }, { symbol: '→', name: 'right arrow' }, { symbol: '←', name: 'left arrow' }, { symbol: '↑', name: 'up arrow' }, { symbol: '↓', name: 'down arrow' }, { symbol: '⊂', name: 'subset of' }, { symbol: '⊆', name: 'subset or equal' }, { symbol: '⊄', name: 'not a subset of' }, { symbol: '∅', name: 'empty set' }, { symbol: '∧', name: 'logical and' }, { symbol: '∨', name: 'logical or' }, { symbol: '¬', name: 'logical not' }, { symbol: '⊕', name: 'circled plus' }, { symbol: '⊗', name: 'circled times' }, { symbol: '≤', name: 'less than or equal' }, { symbol: '≥', name: 'greater than or equal' }, { symbol: 'Σ', name: 'capital sigma' }, { symbol: 'Π', name: 'capital pi' }, { symbol: 'Γ', name: 'capital gamma' }, { symbol: 'Λ', name: 'capital lambda' }, { symbol: 'Δ', name: 'capital delta' }, { symbol: 'α', name: 'alpha' }, { symbol: 'β', name: 'beta' }, { symbol: 'γ', name: 'gamma' }, { symbol: 'δ', name: 'delta' }, { symbol: 'θ', name: 'theta' }, { symbol: 'λ', name: 'lambda' }, { symbol: 'μ', name: 'mu' }, { symbol: 'π', name: 'pi' }, { symbol: 'φ', name: 'phi' }, { symbol: 'ω', name: 'omega' }];
const matdowninputEl = document.getElementById('algorithmInput');
const matdownContextMenuEl = document.getElementById('matdownContextMenu');
const searchEl = document.getElementById('searchSymbols');
const symbolListEl = document.getElementById('symbolList');
let lastCaretPosition = 0;

matdowninputEl.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  lastCaretPosition = matdowninputEl.selectionStart;
  matdownContextMenuEl.style.left = e.pageX + 'px';
  matdownContextMenuEl.style.top = e.pageY + 'px';
  searchEl.value = '';
  renderSymbols(mathSymbols);
  matdownContextMenuEl.style.display = 'block';
  searchEl.focus();
});

document.addEventListener('click', (e) => {
  if (!matdownContextMenuEl.contains(e.target) && e.target !== matdowninputEl) {
    matdownContextMenuEl.style.display = 'none';
  }
});

searchEl.addEventListener('input', () => {
  const query = searchEl.value.toLowerCase();
  const filtered = mathSymbols.filter(item =>
    item.symbol.includes(query) || item.name.includes(query)
  );
  renderSymbols(filtered);
});

function renderSymbols(symbols) {
  symbolListEl.innerHTML = '';
  symbols.forEach(item => {
    const div = document.createElement('div');
    div.className = 'symbolItem';
    div.textContent = `${item.symbol} (${item.name})`;
    div.onclick = () => insertSymbol(item.symbol);
    symbolListEl.appendChild(div);
  });
}

function insertSymbol(symbol) {
  const v = matdowninputEl.value;
  matdowninputEl.value = v.slice(0, lastCaretPosition) + symbol + v.slice(lastCaretPosition);
  matdowninputEl.focus();
  matdowninputEl.setSelectionRange(lastCaretPosition + symbol.length, lastCaretPosition + symbol.length);
  matdownContextMenuEl.style.display = 'none';
}

renderSymbols(mathSymbols);
</script>

</body>
</html>
